<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#">
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../css/style_en.css"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<title>The Fallacy of the Big Round Ball - Project Manager 97Things</title>
<meta property="og:title" content="The Fallacy of the Big Round Ball">
<meta property="og:type" content="article">
<meta property="og:image" content="https://yoshi389111.github.io/kinokobooks/images/mngr97_en.png">
<meta property="og:url" content="https://yoshi389111.github.io/kinokobooks/mngr_en/The_Fallacy_of_the_Big_Round_Ball.htm">
<meta property="og:site_name" content="97 Things Every Project Manager Should Know.">
<meta property="og:locale" content="en_US">
<script type="text/javascript" src="../js/darkmode.js"></script>
</head>
<body>
<article>
<header>
<h1>The Fallacy of the Big Round Ball</h1>

<p><b>David Wood</b>
<i>Fredericksburg, Virginia, USA</i></p>
</header>

<p>Picture a ball, manufactured to be perfectly spherical, perfectly smooth. The only design requirement for this ball is that its diameter be exact when measured at any point. This ball is polished and polished and polished some more until it is perfect. Once no defects can be found, all work on the ball stops. It may not be changed. It is perfection. 
</p><p>Does that sound like any software project you have ever worked on? I didn't think so. Software just doesn't work like that.
</p><p>Software changes constantly throughout its life cycle. Design decisions, so often based on initial requirements, suddenly seem restrictive when new requirements emerge. Hacks to adapt the code to new requirements violate the design and make the code progressively less maintainable. The ball, however round it was intended to be, becomes battered and bruised.
</p><p>The Fallacy of the Big Round Ball is the delusion that software system requirements don't change appreciably after delivery or, worse, that they can be controlled.
</p><p>Early software engineering researchers believed that if requirements could be fully understood before coding began there would be no maintenance crisis. Some took note of problems created by post-delivery changes to requirements and labeled them evil; static requirements yielded more stable systems. Some sought to limit a user's right to request changes (e.g., &#x201c;Reduce the need for change maintenance by planning for and controlling user enhancements&#x201d; was one of a list of &#x201c;solutions to maintenance&#x201d; suggested by James Martin and Carma McClure in 1983).
</p><p>Unfortunately, such strict controls have the unintended side effect of making a software system less useful to its end-users. Such decisions, often based upon short-term economics, were greatly responsible for the alienation of information technology departments from their user bases in the 1990s and the subsequent development of smaller, often duplicate, software systems within business units during that period.
</p><p>The sands of requirements constantly shift under our feet. Requirements for software projects change for some very good, and very simple, reasons. First, they can. Software is a malleable medium. It is generally much more cost effective to change software than to make equivalent changes to hardware.
</p><p>Second, users of software most often exist within competitive environments. They compete with each other and with other organizations. As they struggle to compete, they turn to the most malleable parts of their systems for new advantages. Software's flexibility is enticing.
</p><p>If we give up on the Fallacy of the Big Round Ball, we can become more comfortable with changing requirements and see software malleability for what it is; a huge advantage that we control. Requirements will change. We will have to maintain our code. We will have to inject new requirements that will lead to violations of our designs. That is a feature, as the saying goes, not a bug.
</p><p>We can design adaptable software, but only if we adapt our thinking first. Adaptability, flexibility of design, and readiness for change should be the cornerstones of any new software project.
</p>

<footer>
<p class="license">This work is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/us/" class="external text" title="https://creativecommons.org/licenses/by/3.0/us/" rel="nofollow">Creative Commons Attribution 3</a></p>

</footer>
</article>
</body>
</html>

