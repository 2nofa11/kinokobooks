<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#">
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../css/style_en.css"/>
<title>Avoid Whack-a-Mole Development - Project Manager 97Things</title>
<meta property="og:title" content="Avoid Whack-a-Mole Development">
<meta property="og:type" content="article">
<meta property="og:image" content="https://yoshi389111.github.io/kinokobooks/images/mngr97_en.png">
<meta property="og:url" content="https://yoshi389111.github.io/kinokobooks/mngr_en/Savor_Sustainable_Progress_not_Speed.htm">
<meta property="og:site_name" content="97 Things Every Project Manager Should Know.">
<meta property="og:locale" content="en_US">

</head>
<body>
<article>
<header>
<h1>Avoid Whack-a-Mole Development</h1>

<p><b>Venkat Subramaniam</b>
<i>Broomfield, Colorado, USA</i></p>
</header>

<p>Software project managers face a lot of pressure to deliver fast. Time is of essence. How can you get things done fast?
</p><p>Imagine you have two programmers in your team, Bernie and Rob. Both are capable, have the same amount of domain knowledge, and equal languages skills. During development, you find that Bernie finishes his feature implementations much faster than Rob.
</p><p>While Bernie focuses on getting the code completed quickly, Rob spends time writing code and then refactoring* it. He names the variables and methods better. Once he gets things working, he breaks the code into smaller sized pieces. Now he writes tests to make sure each piece of his code does what he meant it to do. When he's reasonably satisfied, he declares the coding of that functionality done.
</p><p>But assume you don't know these details. If you only look at the speed with which the functionalities are declared done, clearly Bernie is the better man, right?
</p><p>A few weeks go by and you demonstrate the features to your customer. As usual, the customer loves your completed features, but now wants you to change and improve them. You ask your developers to make those code alterations. When you take the new and improved functionality back to your customer, they try out the features that Rob implemented and are pleased with the changes.
</p><p>Unfortunately, they discover something odd with the features that Bernie implemented. While Bernie has programmed in the new functions fine, now a few things that worked before don't work anymore. The customer marks these as defects, and you ask Bernie to fix them. The customer tests the features again. Now even newer, stranger things seem to be broken. What's going on here?
</p><p>If you have a child, you know what is happening. Bernie has created a Whack-A-Mole application. Whack-A-Mole is a toy. Kids are given a wooden hammer and asked to strike moles that pop-up at random. It's fun for them to be surprised by which mole pops up next. However, fixing applications with broken code popping up at random places is not fun. It is frustrating, unpredictable, and it slows your product development. Bernie was sprinting initially, but he was running in the wrong direction.
</p><p>While Rob appeared slower at the outset, he was actually creating superior code. His pace proved sustainable. The better quality of his initial code helped him make workable changes quickly. Plus, the tests he wrote in the beginning gave him instant feedback regarding whether or not his new code was compatible with other parts of the application where the code was used.
</p><p>When measuring time for a feature implementation, do not consider only the time it takes to write it in the first place. Add the time it takes to enhance, fix, and improve the code. Writing good quality code and tests takes time. It appears to be a short-term loss. However, it comes with a long-term gain.
</p><p>Ask yourself if you want speed, or if you want to savor sustainable progress.
</p>
<ul>
<li>Refactoring - Reworking the body of code to improve its internal structure without changing its external function. It improves the software design. So refactoring code is going back to improve a working feature that was created quickly and tested. Now it needs further internal refinement to facilitate it's long term use and make it easier to add future changes.</li>
</ul>


<footer>
<p class="license">This work is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/us/" class="external text" title="https://creativecommons.org/licenses/by/3.0/us/" rel="nofollow">Creative Commons Attribution 3</a></p>

</footer>
</article>
</body>
</html>

