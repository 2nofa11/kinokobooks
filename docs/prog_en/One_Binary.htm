<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#">
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../css/style_en.css"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<title>One Binary - Programmer 97-things</title>
<meta property="og:title" content="One Binary">
<meta property="og:type" content="article">
<meta property="og:image" content="https://yoshi389111.github.io/kinokobooks/images/prog97_en.png">
<meta property="og:url" content="https://yoshi389111.github.io/kinokobooks/prog_en/One_Binary.htm">
<meta property="og:site_name" content="97 Things Every Programmer Should Know.">
<meta property="og:locale" content="en_US">
<script type="text/javascript" src="../js/darkmode.js"></script>
</head>
<body>
<article>
<header>
<h1 class="firstHeading">One Binary</h1>
</header>

<p>I've seen several projects where the build rewrites some part of the code to generate a custom binary for each target environment. This always makes things more complicated than they should be, and introduces a risk that the team may not have consistent versions on each installation. At a minimum it involves building multiple, near-identical copies of the software, each of  which then has to be deployed to the right place. It means more moving parts than necessary, which means more opportunities to make a mistake. 
</p>
<p>I once worked on a team where every property change had to be checked in for a full build cycle, so the testers were left waiting whenever they needed a minor adjustment (did I mention that the build took too long as well?). I also worked on a team where the system administrators insisted on rebuilding from scratch for production (using the same scripts that we did), which meant that we had no proof that the version in production was the one that had been through testing. And so on.
</p>
<p>The rule is simple: <i>Build a single binary that you can identify and promote through all the stages in the release pipeline.</i> Hold environment-specific details <i>in the environment</i>. This could mean, for example, keeping them in the component container, in a known file, or in the path. 
</p>
<p>If your team either has a code-mangling build or stores all the target settings with the code, that suggests that no one has thought through the design carefully enough to separate those features which are core to the application and those which are platform-specific. Or it could be worse: The team knows what to do but can't prioritize the effort to make the change. 
</p>
<p>Of course, there are exceptions: You might be building for targets that have significantly different resource constraints, but that doesn't apply to the majority of us who are writing "database to screen and back again" applications. Alternatively, you might be living with some legacy mess that's too hard to fix right now. In such cases, you have to move incrementally &mdash; but start as soon as possible.
</p>
<p>And one more thing: Keep the environment information versioned too. There's nothing worse than breaking an environment configuration and not being able to figure out what changed. The environmental information should be versioned separately from the code, since they'll change at different rates and for different reasons. Some teams use distributed version control systems for this (such as bazaar and git), since they make it easier to push changes made in production environments &mdash; as inevitably happens &mdash; back to the repository.
</p>
<footer>
<p class="author">By Steve Freeman
</p>
<p class="license">This work is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/us/" class="external text" title="https://creativecommons.org/licenses/by/3.0/us/" rel="nofollow">Creative Commons Attribution 3</a>
</p>

</footer>
</article>
</body>
</html>
