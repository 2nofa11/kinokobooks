<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#">
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../css/style_en.css"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<title>Get the 1000ft view - Software Architect 97Things</title>
<meta property="og:title" content="Get the 1000ft view">
<meta property="og:type" content="article">
<meta property="og:image" content="https://yoshi389111.github.io/kinokobooks/images/soft97_en.png">
<meta property="og:url" content="https://yoshi389111.github.io/kinokobooks/soft_en/Get_the_1000ft_view.htm">
<meta property="og:site_name" content="97 Things Every Software Architect Should Know.">
<meta property="og:locale" content="en_US">

</head>
<body>
<article>
<header>
<h1>Get the 1000ft view</h1>
</header>

<p>As an architect we want to know how good the software is that we are
developing. Its quality has an obvious external aspect, the software
should be of value to its users, but there is also a more elusive
internal aspect to quality, to do with the clarity of the design, the
ease with which we can understand, maintain, and extend the software.
When pressed for a definition, this is where we usually end up saying
"I know it when I see it." But how can we see quality? 
In an architecture diagram little boxes represent entire
systems and lines between them can mean anything: a dependency, the
flow of data, or a shared resource such as a bus. These diagrams are a
30.000ft view, like a landscape seen from a plane. Typically the only
other view available is the source code, which is comparable to a
ground level view. Both views fail to convey much information about the
quality of the software, one is too high level and the other provides
so much information that we cannot see structure. Clearly, what is
missing is a view in between, a 1000ft view.
</p><p>This 1000ft view would provide information at the right level.
It aggregates large amounts of data and multiple metrics, such as
method count, class fan out, or cyclomatic complexity. The actual view
very much depends on a specific aspect of quality. It can be a visual
representation of a dependency graph, a bar chart that shows metrics at
a class level, or a sophisticated polymetric view that correlates
multiple input values.
</p><p>Manually creating such views and keeping them in sync with the
software is a hopeless endeavor. We need tools that create these views
from the only true source, the source code. For some views, a design
structure matrix for example, commercial tools exists but it is also
surprisingly easy to create specialized views by combining small tools
that extract data and metrics with generic visualization packages. A
simple example would be to load the output from checkstyle, which is
essentially a set of metrics on the class and method level, into a
spreadsheet to render charts. The same metrics could also be shown as a
tree-map using the InfoViz toolkit. A great tool to render complex
dependency graphs is GraphViz.
</p><p>Once a suitable view is available software quality becomes a
little less subjective. It is possible to compare the software under
development with a handful of similar systems. Comparing different
revisions of the same system will give an indication of trends while
comparing views of different subsystems can highlight outliers. Even
with just a single diagram we can rely on our ability to spot patterns
and perceive aesthetics. A well-balanced tree probably represents a
successful class hierarchy, a harmonious set of boxes might show code
that is organized into appropriately sized classes. Most of the time a
very simple relationship holds: If it looks good it probably is good. 
</p>

<footer>
<p class="author">By Erik Doernenburg</p>
<p class="license">This work is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/us/" class="external text" title="https://creativecommons.org/licenses/by/3.0/us/" rel="nofollow">Creative Commons Attribution 3</a></p>

</footer>
</article>
</body>
</html>

