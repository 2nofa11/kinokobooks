<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns#">
<head>
<meta charset="UTF-8">
<link rel="stylesheet" href="../css/style_en.css"/>
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<title>The Importance of Consomm&#xe9; - Software Architect 97Things</title>
<meta property="og:title" content="The Importance of Consomm&#xe9;">
<meta property="og:type" content="article">
<meta property="og:image" content="https://yoshi389111.github.io/kinokobooks/images/soft97_en.png">
<meta property="og:url" content="https://yoshi389111.github.io/kinokobooks/soft_en/The_Importance_of_Consomm%C3%A9.htm">
<meta property="og:site_name" content="97 Things Every Software Architect Should Know.">
<meta property="og:locale" content="en_US">

</head>
<body>
<article>
<header>
<h1>The Importance of Consomm&#xe9;</h1>
</header>

<p>A consomm&#xe9; is an extremely clarified broth, usually made with beef or veal, served as a delicate soup. A well-made consomm&#xe9; is perfectly clear. It is considered challenging and time-consuming to make, because there is only one way to remove the fat and other solids that cloud the broth, and gain the absolute clarity the dish requires: repeated, simple, fine-grained straining. This straining again and again, this hyper-conscious refining of the mixture, creates an intensely rich flavor. It's as if to taste a consomm&#xe9; is to taste the very essence of a thing. That is, in fact, the point of the dish.
</p><p>In culinary schools in America, a simple test is administered to student chefs making consomm&#xe9;: the teacher drops a dime into your amber broth; if you can read the date on the dime resting at the bottom of the bowl, you pass. If you can't, you fail.
</p><p>Software architecture requires a continual refinement of thought, a repeated straining of ideas until we have determined the essence of each requirement in the system. We ask, like Hamlet holding Yorick's skull, what is this thing? What are its properties? Its relations? We clarify our concepts, to make the relations within the architecture verifiably true, internally consistent.
</p><p>Many missed requirements and bugs in software can be traced to ambiguous, general language. Ask customers, developers, analysts and users the same questions repeatedly, until they are drowsy with boredom. Now disguise your question to pose it in a different way, like an attorney looking for a snag in the alibi, to tease out anything new, any differences or contradictions. Strain and strain again.
</p><p>Focus on what can be removed from the concepts presented in the architecture, the nouns that compose them, to determine their essence. Bring surgical precision to the language you find in your requirements, rejecting ambiguity, generality, unwarranted assumptions, or extraneous verbiage. This serves to make your concepts richer, more robust. Reduce and reduce again.
</p><p>Test statements by asking &#x201c;Would you make the same statement if I appended &#x2018;always and forever and in every circumstance' to it?" People resist committing to absolutes like this, and must refine their words. Force representations of concepts through a linguistic sieve to clarify them. Do this again, until you are left with only the exhaustive list of simple and verifiably true statements that describe the essential nature the system.
</p><p>You'll know when the architecture is finished: when you can look through it and read the date on a dime.
</p>

<footer>
<p class="author">By Eben Hewitt</p>
<p class="license">This work is licensed under a <a href="https://creativecommons.org/licenses/by/3.0/us/" class="external text" title="https://creativecommons.org/licenses/by/3.0/us/" rel="nofollow">Creative Commons Attribution 3</a></p>

</footer>
</article>
</body>
</html>

